% Helper function to define extensibility profile
function y = ext(beta, x)
    C1=abs(beta(1));
    C2=abs(beta(2));
    C3=abs(beta(3));
    a1=beta(4);
    a2=beta(5);
    a3=beta(6);
    y=C1*exp(-(x/a1).^2)+C2*exp(-(x/a2).^2)+C3*exp(-(x/a3).^2);
    %y=C1*exp(-(x/a1).^2)+C2*exp(-(x/a2).^2);
    %y=C1*exp(-(x/a1).^2);
end

% Helper function to define stiffness
function y = youngMod(Ext)
    y = 15000 ./ Ext;
    %y = (8.003 - Ext)* 2e5;
end

% Helper function tet 4xN to face 3x4N
function Y = tetToFace(tets)
    Y = zeros(3,4*size(tets,2));
    for i = 1:size(tets,2)
        Y(:,(4*i)-3) = [tets(1,i); tets(2,i); tets(3,i)];
        Y(:,(4*i)-2) = [tets(1,i); tets(2,i); tets(4,i)];
        Y(:,(4*i)-1) = [tets(1,i); tets(3,i); tets(4,i)];
        Y(:,(4*i)) = [tets(2,i); tets(3,i); tets(4,i)];
    end
end

% Helper Function takes mxN elts to only columns with val
function Y = selectEltsWithVal(elts, val)
    logicalElts = elts == val;
    for j = 1:size(elts,2)
        for i = 1:size(elts,1)
            if logicalElts(i,j) == 1
                logicalElts(:,j) = ones(size(elts,1),1);
                break;
            end
        end
    end
    Y = elts .* logicalElts;
    Y(:,all(Y == 0))=[];
end

% Helper Function to remove all columns that have a duplicate, and their
% duplicate (assumes no nonzero matrix elements)
function Y = rmDupeCols(M)
    Y = sort(M);
    for j = 1:(size(Y,2)-1)
        if Y(1,j) ~= 0
            for i = (j+1):size(Y,2)
                if isequal(Y(:,j), Y(:,i))
                    Y(:,j) = zeros(size(Y,1),1);
                    Y(:,i) = zeros(size(Y,1),1);
                    break;
                end
            end
        end             
    end
    Y(:,all(Y == 0))=[];
end

% Helper function to compute triangle normals (expects 3xN and 3xM),
% returns 3xN
function Y = triangleNormals(faces, points)
    Y = zeros(size(faces));
    for j = 1:size(faces,2)
        v1 = points(:, faces(1,j));
        v2 = points(:, faces(2,j));
        v3 = points(:, faces(3,j));
        edge1 = v2 - v1;
        edge2 = v3 - v1;
        n = cross(edge1, edge2);
        Y(:,j) = n / norm(n);
    end
end

% Helper function takes Mesh to Graph
function G = meshToSparseGraph(V, T)
    % Extract edges from Mx4 tetrahedra matrix (each row has 4 indices of V)
    E = [T(:, [1, 2]); T(:, [2, 3]); T(:, [3, 4]); T(:, [4, 1]); T(:, [1, 3]); T(:, [2, 4])];  % 6Mx2, each row is pair of vertex indices
    E = sort(E, 2);  % Sorts each row (edge)
    E = unique(E, 'rows');  % Remove duplicates

    % Compute edge lengths
    edgeLengths = vecnorm(V(E(:,1),:) - V(E(:,2),:), 2, 2);

    % Create sparse adjacency graph
    G = graph(E(:,1), E(:,2), edgeLengths, size(V,1));
end

%insert structural properties.

nu = 0.3;           % Poisson's ratio
p = 100;            % Pressure
%beta0 = [0.002,0.13875,0.0025,0.0025]'; % Inputs for extensibility profile
% beta0 = [0.00375,0.65,0.005,0.002]'; % Inputs for extensibility profile
%beta0 = [0.002,8,0.0075,0.0005]';
%beta0 = [0.65,0.002]';
beta0 = [0.002,0.648,2,0.0075,0.002,0.0007]';

% Define pole column for knnsearch
colN = 8;  % Choose however many points you want
colp1 = [0, 0, 0.002];
colp2 = [0, 0, 0.008];
colt = linspace(0, 1, colN)';   % N values from 0 to 1 (column vector)
poleColumn = (1 - colt) * colp1 + colt * colp2; 

warning('off', 'MATLAB:alphaShape:DupPointsBasicWarnId');
timeSteps = 10;
%frames(timeSteps) = struct('cdata', [], 'colormap', []);
thicknesses = zeros(1, timeSteps);
heights = zeros(1, timeSteps);
volumes = zeros(1, timeSteps);
v = VideoWriter('my_animation.avi');
v.FrameRate = 15;
v.Quality = 100;
open(v);
figure;
i = 1;
while i <= timeSteps
    fprintf('Time Step %d\n', i-1);
    if i > 1
        % Initialize femodel with geometry from previous iter
        model = femodel("AnalysisType","structuralStatic");
        model.Geometry = fegeometry(corrDispNodes, corrElts);
    else
        % Initialize femodel with initial geometry
        model = femodel("AnalysisType","structuralStatic","Geometry", "HollowHemisphere.step");
    end
    %{
    % Plot geometry
    figure;
    pdegplot(model.Geometry, VertexLabels='on', FaceLabels='on', FaceAlpha=0.5);
    axis equal;
    title(['geometry ', num2str(i)])
    %}

    % Generate tetrahedral mesh, can specify resolution
    %model = generateMesh(model, 'Hmax', 0.0003, 'Hmin', 0.00014, 'GeometricOrder', 'linear');
    model = generateMesh(model, 'Hmax', 0.0003, 'Hmin', 0.00028, 'GeometricOrder', 'linear');
    %model = generateMesh(model, 'Hmax', 0.0003, 'GeometricOrder', 'linear');
    %mesh = model.Mesh;
    %{
    % Plot mesh
    figure;
    pdeplot3D(mesh, 'FaceAlpha', 0.3);
    %}

    elemZCoords = reshape(model.Mesh.Nodes(3,model.Mesh.Elements),4,[]);
    elemZCoordsGeometricCenter = mean(elemZCoords);
    ElementIdToRegionId = ones(1,size(model.Mesh.Elements,2));
    idxSplit = elemZCoordsGeometricCenter < 0.001;
    ElementIdToRegionId(idxSplit) = linspace(2, size(ElementIdToRegionId(idxSplit),2) + 1, size(ElementIdToRegionId(idxSplit),2));
    
    %gmTwoDomains = fegeometry(model.Mesh.Nodes',model.Mesh.Elements',newElementIdToRegionId);
    gmTwoDomains = fegeometry(model.Mesh.Nodes',model.Mesh.Elements',ElementIdToRegionId);
    model.Geometry = gmTwoDomains;
    figure;
    pdegplot(model.Geometry, FaceAlpha=0.5);
    axis equal;
    title(['geometry ', num2str(i)]);
    model = generateMesh(model, 'Hmax', 0.0003, 'Hmin', 0.00028, 'GeometricOrder', 'linear');
    mesh = model.Mesh;
    
    numFaces = model.Geometry.NumFaces;
    faceNodeIdx = cell(1, numFaces);
    maxvec = zeros(1, numFaces);
    faces = linspace(1, numFaces, numFaces);
    for j = 1:numFaces
        faceNodeIdx{j} = findNodes(mesh, 'region', 'Face', j);
        maxvec(j) = max(mesh.Nodes(3, faceNodeIdx{j}));
    end
    [~, idx] = sort(maxvec, 'Descend');
    facesSorted = faces(idx);
    if i == 1
        V = 1.9924e-06;
        volumes(1,i) = V;
        PV_ratio = p / V;
    end
    
    % max z pole finder (worse)
    %[~, poleIdx] = max(mesh.Nodes(3,:));

    % projected pole finder (better)
    tempOuterCoords = mesh.Nodes([1, 2],faceNodeIdx{facesSorted(1)});
    poleIdxOuter = knnsearch(tempOuterCoords',[0,0]);
    poleIdx = faceNodeIdx{facesSorted(1)}(1,poleIdxOuter);

    poleCoords = mesh.Nodes(:,poleIdx);
    heights(1,i) = poleCoords(3,1);
    %fprintf("Pole index is %d, pole coords are [%d, %d, %d]\n", poleIdx, poleCoords(1, 1), poleCoords(2, 1), poleCoords(3, 1));

    tempInnerCoords = mesh.Nodes(:,faceNodeIdx{facesSorted(2)});
    innerIdx = knnsearch(tempInnerCoords',poleCoords');
    innerCoords = tempInnerCoords(:,innerIdx);
    %thickness = abs(dot((poleCoords - innerCoords), avgNormal))
    thickness = abs(dot((poleCoords - innerCoords), [0; 0; 1]))
    thicknesses(1,i) = thickness;
    model.FaceLoad(facesSorted(2)) = faceLoad(Pressure = PV_ratio * V);
    %model.FaceBC([facesSorted(3),facesSorted(4)]) = faceBC(Constraint="fixed");
    bottomFaceIDs = cellFaces(model.Geometry, 2:(size(ElementIdToRegionId(idxSplit),2) + 1));
    model.FaceBC(bottomFaceIDs) = faceBC(Constraint="fixed");

    %}
    % Compute lengths of geodesics. s stores arclength.
    G = meshToSparseGraph(mesh.Nodes', mesh.Elements');
    s = distances(G, poleIdx);  % s(i) is geodesic Dijkstra distance to vertex i
    kdtree = createns(mesh.Nodes', 'NSMethod', 'kdtree');
    val = @(location,state) youngMod(ext(beta0, s(knnsearch(kdtree, ...
    [location.x(:), location.y(:), location.z(:)]))));
    model.MaterialProperties(1).PoissonsRatio = nu;
    model.MaterialProperties(1).YoungsModulus = val;
    for k = 2:(size(ElementIdToRegionId(idxSplit),2) + 1)
        model.MaterialProperties(k).PoissonsRatio = nu;
        model.MaterialProperties(k).YoungsModulus = val;
        fprintf('assigned %d of %d\n', k, size(ElementIdToRegionId(idxSplit),2) + 1);
    end

    results = solve(model);
    u = results.Displacement;
    %figure;
    clf;
    pdeplot3D(model.Mesh,'ColorMapData', u.Magnitude, 'FaceAlpha', 0.3, ...
        'Deformation', u, ...
        'DeformationScaleFactor', 1);
    clim([0 4e-5]);
    axis([-0.011 0.011 -0.011 0.011 -0.001 0.025]);
    view(90, 0);
    ax.CameraPositiion = [0.8, 0, 0.0125];
    %camtarget([0, 0, 0.0125]);
    title(['Loop displacement colormap ', num2str(i)]);
    drawnow;
    frame = getframe(gcf);
    writeVideo(v, frame);
    displacedNodes = model.Mesh.Nodes + [u.ux'; u.uy'; u.uz'];
    elements = model.Mesh.Elements;
    [corrDispNodes, corrElts, V] = thicknessForcing(displacedNodes', elements', poleColumn);
    i = i + 1;
end
warning('on', 'MATLAB:alphaShape:DupPointsBasicWarnId');
close(v);
ffmpegPath = '/opt/homebrew/bin/ffmpeg';
inFile = 'my_animation.avi';
outFile = 'my_animation.mp4';
delete('my_animation.mp4');
cmd = sprintf('"%s" -i "%s" -vcodec libx264 -crf 18 "%s"', ffmpegPath, inFile, outFile);
system(cmd);
delete('my_animation.avi');


    % Plot alphashape
    figure;
    h = plot(shp);
    h.FaceAlpha = 0.3;
    

time = 0:1:timeSteps-1;
figure;
plot(time,thicknesses);
title('Thickness over time');
figure;
plot(time,heights);
title('Height over time');
figure;
dheights = zeros(1,timeSteps);
for i = 2:timeSteps
    dheights(1,i) = heights(1,i) - heights(1,i-1);
end
plot(time,dheights);
title('Change in Height over time');
figure;
plot(time,volumes);
title('Volume over time');
