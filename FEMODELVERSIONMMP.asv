% Helper function to define extensibility profile
function y = ext(beta, x)
    C1=abs(beta(1));
    C2=abs(beta(2));
    a1=beta(3);
    a2=beta(4);
    y=C1*exp(-(x/a1).^2)+C2*exp(-(x/a2).^2)+0.0001; %0.0001 so no 0
end

% Helper function to define stiffness
function y = youngMod(Ext)
    y = 500 ./ Ext;
end

% Initialize femodel with single domain geometry
model = femodel("AnalysisType","structuralStatic","Geometry", "HollowHemisphere.step");
g = model.Geometry;

% Plot geometry
figure;
pdegplot(g, FaceLabels='on', FaceAlpha=0.5);
axis equal;
title('initial single-domain geometry')

% Generate tetrahedral mesh, can specify resolution
model = generateMesh(model, 'Hmax', 0.0003, 'Hmin', 0.0002, 'GeometricOrder', 'linear');
size(model.Mesh.Nodes)

% Plot mesh
figure;
pdemesh(model,'FaceAlpha', 0.3);
title('Tetrahedral Mesh of Direct hollow sphere');

% TOPOLOGICAL MANIFOLD EXTRACTION PROCESS FOR CGAL GEODESIC
% Step 1: Get free boundary
V = model.Mesh.Nodes';
T = model.Mesh.Elements';
TR = triangulation(T, V);
[F, V] = freeBoundary(TR);

% Step 2: Clean up vertex indexing
[uniqueVerts, ~, ic] = unique(F(:));
V_clean = V(uniqueVerts, :);
F_clean = reshape(ic, size(F));

% Step 3: Create triangulation for boundary faces
TR_surf = triangulation(F_clean, V_clean);
faceAdj = TR_surf.neighbors;

% Step 4: Efficient BFS to find connected components
numFaces = size(F_clean, 1);
componentId = zeros(numFaces, 1);
currentComponent = 0;

for i = 1:numFaces
    if componentId(i) > 0
        continue;
    end
    % Start new component
    currentComponent = currentComponent + 1;
    queue = i;
    componentId(i) = currentComponent;

    while ~isempty(queue)
        f = queue(end);
        queue(end) = [];

        neighbors = faceAdj(f, :);
        neighbors = neighbors(~isnan(neighbors));  % remove NaNs
        for n = neighbors
            if componentId(n) == 0
                componentId(n) = currentComponent;
                queue(end+1) = n; %#ok<AGROW>
            end
        end
    end
end

% Step 5: Select the largest component (assumed outer surface)
counts = histcounts(componentId, 1:max(componentId)+1);
[~, largestComponent] = max(counts);
keepFaces = find(componentId == largestComponent);
F_final = F_clean(keepFaces, :);

% Step 6: Reindex vertices
[uniqueVerts2, ~, ic2] = unique(F_final(:));
V_final = V_clean(uniqueVerts2, :);
F_final = reshape(ic2, size(F_final));

% Step 7: Visualize manifold
figure;
trisurf(F_final, V_final(:,1), V_final(:,2), V_final(:,3), ...
    'FaceAlpha', 0.6);
title('manifold mesh');
axis equal;

% Find index of pole vertex
poleCoord = [0, 0, 0.01];           % Your pole location
poleIdx = knnsearch(V_final, poleCoord);  % Closest vertex on the surface
fprintf("Pole index is %d, pole coords are [%d, %d, %d]\n", ...
    poleIdx, ...
    V_final(poleIdx, 1), ...
    V_final(poleIdx, 2), ...
    V_final(poleIdx, 3));

targetCoord = [-0.00545175, -0.00450885, 0.007044]; % a target point
targetIdx = knnsearch(V_final, targetCoord); % the closest node to target
fprintf("Random target point index is %d\n", targetIdx);

% CALL WRITE_OFF HELPER FILE TO CONVERT MANIFOLD TO .OFF FOR CGAL
offFileName = 'init_mesh_test.off';
write_off(offFileName, V_final, F_final);
cppFolder = fullfile(pwd, 'cgal_geodesic', 'build');
sourceOFF = fullfile(pwd, offFileName);
destOFF = fullfile(cppFolder, offFileName);
movefile(sourceOFF, destOFF);

exeBaseName = 'geodesic_example';
exePath = fullfile(cppFolder, exeBaseName);

if ispc
    exeName = [exeBaseName, '.exe'];
    exeCommand = sprintf('%s %s %d', exeName, offFileName, poleIdx-1);
else
    exeName = exeBaseName;
    [status, cmdout] = system(['cd ', cppFolder, ' && ./geodesic_example']);
end

if status ~= 0
    error('C++ executable failed:\n%s', cmdout);
end
disp('C++ processing complete.');

movefile(fullfile(cppFolder, 'mmpdistances.txt'), fullfile(pwd, 'mmpdistances.txt'));
movefile(fullfile(cppFolder, 'path.txt'), fullfile(pwd, 'path.txt'));

%{
% READ IN GEODESICS FROM TEXT FILE
geodistances = readmatrix('mmpdistances.txt'); % Nx2 matrix (vertIdx, geodist)
vertex_indices = geodistances(:,1) + 1; % C++ is 0-idxed, MATLAB is 1-idxed
Dist = geodistances(:,2);

% Visualize geodesic distance on manifold by color
figure;
trisurf(F_final, V_final(:,1), V_final(:,2), V_final(:,3), Dist, ...
        'EdgeColor', 'none', 'FaceAlpha', 0.9);
colormap(turbo); colorbar;
title('MMP Geodesic Distance from Pole');
hold on;
axis equal;

P = readmatrix("path.txt");
plot3(P(:,1), P(:,2), P(:,3), 'r-', 'LineWidth', 2);

nu = 0.3;           % Poisson's ratio
p = 1e2;            % Pressure

beta0 = [0.00375,0.13875,0.01,0.001]'; % Inputs for extensibility profile
kdtree = createns(V_final, 'NSMethod', 'kdtree');
val = @(location,state) youngMod(ext(beta0, Dist(knnsearch(kdtree, ...
    [location.x(:), location.y(:), location.z(:)]))))';

% Here are the material properties
model.MaterialProperties.PoissonsRatio = nu;
model.MaterialProperties.YoungsModulus = val;

% Applying Neumann boundary conditions to inner faces
model.FaceLoad(3) = faceLoad(Pressure = p); % Pressure in Pascals

% Applying Dirichlet boundary conditions to bottom
model.FaceBC([2,4]) = faceBC(Constraint="fixed");

fprintf('BCs and Material Properties set.\n');
results = solve(model);
fprintf('Solved!\n');

% visualize
u = results.Displacement;
figure;
pdeplot3D(model.Mesh,'ColorMapData', u.Magnitude, 'FaceAlpha', 0.3, ...
    'Deformation', u, ...
    'DeformationScaleFactor', 1);
title('MMP Displacement colormap')
%}